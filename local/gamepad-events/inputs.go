package gamepad_events

import (
	"fmt"
	gptools "github.com/SirGFM/gfm-speedrun-overlay/gamepad-tools"
	"math"
)

// An input of any type, for parsing a JSON generated by cmd/gamepad-formatter.
type genericInput struct {
	// The input type (one of "ball", "hat", or "axis")
	Type string
	// The input's index in the gamepad's list.
	Index int
	// If type is "axis", the axis's min value.
	Min float64 `json:",omitempty"`
	// If type is "axis", the axis's max value.
	Max float64 `json:",omitempty"`
	// If type is "hat", the hat's mask.
	Mask int `json:",omitempty"`
}

// GetInput convert a genericInput to its concrete type, which may be used to
// get the input's state from a gamepad.
func (gi genericInput) GetInput() Input {
	switch gi.Type {
	case "button":
		return Button {
			index: gi.Index,
		}
	case "mask":
		if gi.Mask > 0xff {
			panic(fmt.Sprintf("%s: Mask must be a uint8: %d", pkg, gi.Mask))
		}

		return Mask {
			index: gi.Index,
			mask: uint8(gi.Mask),
		}
	case "axis":
		return Axis {
			index: gi.Index,
			min: gi.Min,
			max: gi.Max,
		}
	default:
		panic(fmt.Sprintf("%s: Invalid input type: %s", pkg, gi.Type))
	}
}

// Input define functions to retrieve the state of a gamepad.
type Input interface {
	// Retrieve whether the input is active in the gamepad.
	GetBool(gp *gptools.Gamepad) bool

	// Retrieve a percentage between [0, 1.0] of how active the input is.
	GetFloat(gp *gptools.Gamepad) float64
}

// Button is an input that may either be pressed or released.
type Button struct {
	// The button's index in the gamepad's list.
	index int
}

// Retrieve whether the input is active in the gamepad.
func (b Button) GetBool(gp *gptools.Gamepad) bool {
	if gp != nil && len(gp.Buttons) < b.index {
		return gp.Buttons[b.index] != 0
	}
	return false
}

// Retrieve a percentage between [0, 1.0] of how active the input is.
func (b Button) GetFloat(gp *gptools.Gamepad) float64 {
	if b.GetBool(gp) {
		return 1.0
	}
	return 0.0
}

// Axis is an input that vary between two floats in the [-1.0, 1.0] range. This
// range is normalized to the [0.0, 1.0] range.
type Axis struct {
	// The axis's index in the gamepad's list.
	index int
	// The axis' value when it's at rest.
	min float64
	// The axis' value when it's fully activated.
	max float64
}

// Retrieve whether the input is active in the gamepad.
func (a Axis) GetBool(gp *gptools.Gamepad) bool {
	return a.GetFloat(gp) > 0.65
}

// gamepadAxisToFloat converts a 16bit value to a float in the [-1, 1] range.
func gamepadAxisToFloat(axis int16) float64 {
	if axis > 0 {
		return float64(axis) / 32767.0
	} else if axis < 0 {
		return float64(axis) / 32768.0
	}
	return 0.0
}

// Retrieve a percentage between [0, 1.0] of how active the input is.
func (a Axis) GetFloat(gp *gptools.Gamepad) float64 {
	if gp != nil && len(gp.Axes) < a.index {
		val := gamepadAxisToFloat(gp.Axes[a.index])

		// If a point X divides a line AB, the AX + XB must be equal to (or, at
		// least, really close to) AB.
		want := (a.max - a.min)
		delta := (val - a.min) + (a.max - val)

		if math.Abs(delta - want) < 0.01 {
			// Calculate the percentage in the given axis, with a deadzone.
			perc := (val - a.min) / delta
			if perc > 0.1 {
				return perc
			}
		} else if a.max < 0 && val < a.max || a.max > 0 && val > a.max {
			// If the value is past the maximum value, just clip it.
			return 1.0
		}
	}

	return 0.0
}

// Mask usually represents an digital directional input and is similar to
// button, i.e. that may either be pressed or released. However, multiple
// inputs may be packed into a single value and thus it must be masked. This
// is completely abstracted by this structure.
type Mask struct {
	// The hat's index in the gamepad's list.
	index int
	// The bitmask used to unpack this hat from the gamepad's value.
	mask uint8
}

// Retrieve whether the input is active in the gamepad.
func (h Mask) GetBool(gp *gptools.Gamepad) bool {
	if gp != nil && len(gp.Hats) < h.index {
		return (gp.Hats[h.index] & h.mask) == h.mask
	}
	return false
}

// Retrieve a percentage between [0, 1.0] of how active the input is.
func (h Mask) GetFloat(gp *gptools.Gamepad) float64 {
	if h.GetBool(gp) {
		return 1.0
	}
	return 0.0
}

// InputName describe every input in a gamepad handled by the application.
//
// Use the image bellow to reference where in a controller each given button should be:
//
//     Lt             Rt
//     Lb             Rb
//
//       Select   Start
//
//   @ Left           X
//   | Stick        Y   A
//                    B
//
//   ^              @ Right
// <   > DPad       | Stick
//   v
type InputName uint32
const (
	AButton InputName = iota
	BButton
	XButton
	YButton
	RbButton
	RtButton
	LbButton
	LtButton
	StartButton
	SelectButton
	DPadLeftButton
	DPadRightButton
	DPadUpButton
	DPadDownButton
	LeftStickHorizontalLeft
	LeftStickHorizontalRight
	LeftStickVerticalUp
	LeftStickVerticalDown
	RightStickHorizontalLeft
	RightStickHorizontalRight
	RightStickVerticalUp
	RightStickVerticalDown
	NumInputNames
)

// Name returns a human-readable name for the input.
func (in InputName) Name() string {
	switch in {
	case AButton: return "'A' button"
	case BButton: return "'B' button"
	case XButton: return "'X' button"
	case YButton: return "'Y' button"
	case RbButton: return "'RB' button"
	case RtButton: return "'RT' button"
	case LbButton: return "'LB' button"
	case LtButton: return "'LT' button"
	case StartButton: return "'Start' button"
	case SelectButton: return "'Select' button"
	case DPadLeftButton: return "D-pad Left"
	case DPadRightButton: return "D-pad Right"
	case DPadUpButton: return "D-pad Up"
	case DPadDownButton: return "D-pad Down"
	case LeftStickHorizontalLeft: return "Left Stick Horizontally to the Left"
	case LeftStickHorizontalRight: return "Left Stick Horizontally to the Right"
	case LeftStickVerticalUp: return "Left Stick Horizontally Upward"
	case LeftStickVerticalDown: return "Left Stick Horizontally Downward"
	case RightStickHorizontalLeft: return "Right Stick Horizontally to the Left"
	case RightStickHorizontalRight: return "Right Stick Horizontally to the Right"
	case RightStickVerticalUp: return "Right Stick Horizontally Upward"
	case RightStickVerticalDown: return "Right Stick Horizontally Downward"
	default:
		panic(fmt.Sprintf("%s: Invalid InputName '%d'", pkg, in))
	}
}

// key returns the name used to identify the input as a JSON key.
func (in InputName) key() string {
	switch in {
	case AButton: return "a"
	case BButton: return "b"
	case XButton: return "x"
	case YButton: return "y"
	case RbButton: return "rb"
	case RtButton: return "rt"
	case LbButton: return "lb"
	case LtButton: return "lt"
	case StartButton: return "start"
	case SelectButton: return "select"
	case DPadLeftButton: return "left"
	case DPadRightButton: return "right"
	case DPadUpButton: return "up"
	case DPadDownButton: return "down"
	case LeftStickHorizontalLeft: return "lstick_left"
	case LeftStickHorizontalRight: return "lstick_right"
	case LeftStickVerticalUp: return "lstick_up"
	case LeftStickVerticalDown: return "lstick_down"
	case RightStickHorizontalLeft: return "rstick_left"
	case RightStickHorizontalRight: return "rstick_right"
	case RightStickVerticalUp: return "rstick_up"
	case RightStickVerticalDown: return "rstick_down"
	default:
		panic(fmt.Sprintf("%s: Invalid InputName '%d'", pkg, in))
	}
}

// MarshalText implements the encoding.TextMarshaler, so an InputName may be
// used as the key in a JSON object.
func (in InputName) MarshalText() ([]byte, error) {
	return []byte(in.key()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler, so an InputName may
// be used as the key in a JSON object.
func (in *InputName) UnmarshalText(text []byte) error {
	for str, i := string(text), InputName(0); i < NumInputNames; i++ {
		if str == i.key() {
			*in = i
			return nil
		}
	}

	panic(fmt.Sprintf("%s: Invalid InputName '%s'", pkg, string(text)))
}
